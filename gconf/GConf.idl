
// Really, this whole interface should be used only via the GConf 
// client library. I reserve the right to change it whenever I feel 
// like it. So there.

enum ConfigBasicValueType { BInvalidVal, BIntVal, BStringVal, BFloatVal, BBoolVal, BSchemaVal };

enum ConfigValueType { InvalidVal, IntVal, StringVal, FloatVal, BoolVal, SchemaVal, ListVal, PairVal };

struct ConfigSchema {
  ConfigValueType value_type;
  ConfigValueType value_list_type;
  ConfigValueType value_car_type;
  ConfigValueType value_cdr_type;
  string locale;
  string short_desc;
  string long_desc;
  string owner;
  // Work around lack of recursive data types
  string encoded_default_value;
};

union ConfigBasicValue switch (ConfigBasicValueType) {
 case BInvalidVal:
   long dummy;
 case BIntVal: 
   long int_value;
 case BStringVal:
   string string_value;
 case BFloatVal:
   float float_value;
 case BBoolVal:
   boolean bool_value;
   // hope this doesn't slow down transmission of smaller types 
 case BSchemaVal:
   ConfigSchema schema_value;
};

typedef sequence<ConfigBasicValue> BasicValueList;

struct ConfigList {
  BasicValueList seq;
  ConfigBasicValueType list_type;
};

union ConfigValue switch (ConfigValueType) {
 case InvalidVal:
   long dummy;
 case IntVal:
   long int_value;
 case StringVal:
   string string_value;
 case FloatVal:
   float float_value;
 case BoolVal:
   boolean bool_value;
 case SchemaVal:
   ConfigSchema schema_value;
 case ListVal:
   ConfigList list_value;
 case PairVal:
   BasicValueList pair_value;
};

interface ConfigListener {
  oneway void notify (in unsigned long server_context, // ConfigServer::Context
                      in unsigned long cnxn,
                      in string key, in ConfigValue value,
                      in boolean is_default);

  oneway void ping ();

  /// This should conceivably not be oneway

  oneway void update_listener (in unsigned long old_server_context,
                               in unsigned long old_cnxn,
                               in string key,
                               in unsigned long new_server_context,
                               in unsigned long new_cnxn);
};

// Sync this with GConfErrNo in gconf.h, when it makes sense (e.g. G_CONF_NO_SERVER doesn't
// make sense here)
enum ConfigErrorType {
  ConfigFailed, ConfigNoPermission,
  ConfigBadAddress, ConfigBadKey,
  ConfigParseError, ConfigCorrupt,
  ConfigTypeMismatch, ConfigIsDir, ConfigIsKey,
  ConfigOverridden, ConfigLockFailed
};

exception ConfigException {
  ConfigErrorType err_no;
  string message;
};

interface ConfigServer {
  typedef sequence<string> KeyList;
  typedef sequence<ConfigValue> ValueList;
  typedef sequence<boolean> IsDefaultList;
  typedef unsigned long Context;
  
  const Context invalid_context = 0;
  // user's preferred config database
  const Context default_context = 1;

  // Use a specific address instead of the default database;
  // invalid_context returned on failure.
  Context get_context(in string address);
  
  // "where" is the portion of the namespace to listen to
  // Returns a connection ID for removal
  unsigned long add_listener(in Context ctx, in string where, in ConfigListener who);  

  void remove_listener(in Context ctx, in unsigned long cnxn);
  
  ConfigValue lookup(in Context ctx, in string key)
    raises (ConfigException);

  // separate from lookup for efficiency
  ConfigValue lookup_with_locale(in Context ctx, in string key,
                                 in string locale, in boolean use_schema_default,
                                 out boolean value_is_default)
    raises (ConfigException);

  // syntactic sugar, semi-hack: should maybe use a get_metainfo()
  // function (which we should have anyway)
  ConfigValue lookup_default_value(in Context ctx, in string key,
                                   in string locale)
    raises (ConfigException);
  
  void set(in Context ctx, in string key, in ConfigValue value)
    raises (ConfigException);
  
  void unset(in Context ctx, in string key)
    raises (ConfigException);

  void unset_with_locale(in Context ctx, in string key, in string locale)
    raises (ConfigException);
  
  boolean dir_exists(in Context ctx, in string dir)
    raises (ConfigException);

  void remove_dir(in Context ctx, in string dir)
    raises (ConfigException);

  void all_entries(in Context ctx,
                   in string dir,
                   in string locale,
                   out KeyList keys,
                   out ValueList values,
                   out IsDefaultList is_defaults)
    raises (ConfigException);

  void all_dirs(in Context ctx,
                in string dir,
                out KeyList subdirs)
    raises (ConfigException);

  // if first arg is a key, second arg should be a key pointing
  //  to a schema. 
  // if first arg is a dir, second arg should be a key pointing 
  //  to a dir full of schemas.
  void set_schema(in Context ctx,
                  in string key,
                  in string schema_key)
    raises (ConfigException);

  void sync(in Context ctx)
    raises (ConfigException);

  // Internal use
  long ping();

  void shutdown();

  void clear_cache(in Context ctx);

  void synchronous_sync(in Context ctx);
};
