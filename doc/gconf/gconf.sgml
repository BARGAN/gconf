<!DOCTYPE ARTICLE PUBLIC "-//Davenport//DTD DocBook V3.0//EN" [
]>

<article id="index">
  <artheader>
    <authorgroup>
      <author>
	<firstname>Havoc</firstname>
	<surname>Pennington</surname>
      </author>
    </authorgroup>
    <copyright>
      <year>1999</year>
      <holder>Havoc Pennington</holder>
    </copyright>

    <!-- GConf -->
    <title>GConf</title>
    <abstract>
      <para>
      GConf is a system for storing configuration information, that
      is, key-value pairs. GConf provides a notification service
      so applications can be notified when a key's value is changed.
      GConf also allows for pluggable storage mechanisms (text files,
      databases, etc.) and allows administrators to install default 
      values.
      </para>
      
    </abstract>
  </artheader>
  
  <!-- Introduction to GConf -->
  <sect1>
    <title>Introduction to GConf</title>
    
    <!-- Motivation -->
    <sect2>
      <title>Motivation</title>
      
      <para>   
        GConf is intended to store key-value pairs, where keys are
        located in an infinite tree-structured namespace (similar to the
        UNIX filesystem). It offers several useful features:
        <itemizedlist mark="bullet">
          <listitem>
            <para>
              Users can select a variety of data storage backends, such as
              XML text files, ACAP, or databases (LDAP, DB, etc.). This makes 
              it easy to adapt GConf to local needs. It also avoids the
              age-old "text files vs. binary registry" debate.
            </para>
          </listitem>
          <listitem>
            <para>
              GConf offers a notification service, so applications can 
              ask to be notified when the value of a key changes. 
              This allows settings to be applied to groups of
              applications, without restarting them and without 
              ugly hacks.
            </para>
          </listitem>
          <listitem>
            <para>
              Each user has a "GConf search path" which is a list of 
              configuration sources to scan for each value. 
              For example, the configuration engine might look for 
              values first in the local machine's database and 
              then in a network-wide database.
            </para>
          </listitem>
          <listitem>
            <para>
              GConf is implemented as a per-user daemon, which makes 
              locking a non-issue and allows aggressive caching.
            </para>
          </listitem>
        </itemizedlist>
      </para>

    </sect2>

    <!-- Terms and Concepts -->
    <sect2>
      <title>Terms and Concepts</title>

      <para>
        This section introduces the basic GConf structure and terminology.
      </para>

      <sect3>
        <title>Namespace</title>          
        <para>
          The GConf namespace is almost exactly like the UNIX filesystem; that
          is, a tree structured directory hierarchy. Each name is either a
          "file" (a configuration key storing a value) or a "directory" (a list
          of child configuration key names). A name is specified with a
          slash-separated path. A full path is referred to as a
          <firstterm>key</firstterm>.  Characters in a path should be
          alphanumeric or underscore. Path components may not start with a
          period.
        </para>
      </sect3>

      <!-- Data Types -->
      <sect3>
        <title>GConf Data Types</title>

        <para>
          GConf can only store a small, fixed set of data types. This keeps the
          database implementation simple and efficient. GConf should
          <emphasis>not</emphasis> be used to store data files or any other
          large amount of information; it is designed for simple configuration
          data only.
        </para>

        <para>
          Here are the GConf datatypes:
          <variablelist>
            <varlistentry>
              <term>Integer</term>
              <listitem><para>
                  Integer values are simple C-style integers, that is, they are 
                  limited to 32 bits and can be positive or negative.
                </para></listitem>
            </varlistentry>
            <varlistentry>
              <term>String</term> 
              <listitem><para>
                  String values can contain any text you like,
                  but not binary data (such as the nul character).
                </para></listitem>
            </varlistentry>
            <varlistentry>
              <term>Float</term>
              <listitem><para>
                  Float values are double-precision floating point numbers. 
                </para></listitem>
            </varlistentry>
            <varlistentry>
              <term>Bool</term> 
              <listitem><para>
                  Boolean values are true or false.
                </para></listitem>
            </varlistentry>
            <varlistentry>
              <term>Schema</term>
              <listitem><para>
                  Schemas store a <structname>GConfSchema</structname> 
                  data type, which contains meta-information about a key, such 
                  as documentation and its type. 
                </para></listitem>
            </varlistentry>
            <varlistentry>
              <term>List</term>
              <listitem><para>
                  List values store a group of values. All values
                  in a list must have the same primitive type. Lists of lists and lists of pairs 
                  are not allowed.
                </para></listitem>
            </varlistentry>
            <varlistentry>
              <term>Pair</term> 
              <listitem><para>
                  Pairs store two primitive values. The two values do 
                  not necessarily have the same type. Pairs can not contain pairs or lists, 
                  only primitive types.
                </para></listitem>
            </varlistentry>
          </variablelist>
        </para>

      </sect3>
      
      <!-- Sources -->
      <sect3>
        <title>Configuration Sources</title>

        <para> 
          Users can specify <firstterm>configuration sources</firstterm>
          which will be used by the <command>gconfd</command> per-user
          configuration server.  <command>gconfd</command> loads the file
          <filename>/etc/gconf/path</filename> on startup; this file contains a
          list of <firstterm>configuration source addresses</firstterm>.  A
          source address is similar to a URL; it contains a "protocol" name (in
          this case, the name of the backend to use), followed by a colon and
          backend-specific information. For example, the address <filename>
          xml:/home/hp/.gconf</filename> refers to an XML backend file tree
          rooted at <filename>/home/hp/.gconf.xml</filename>:
        </para>

        <para>
          <filename>/etc/gconf/path</filename> stores a list of addresses, which 
          form a <firstterm>configuration source path</firstterm>. When looking up 
          a value, GConf will begin with the first source in the path, and continue
          checking each source until the value is found or there are no more sources.
          When setting a value, GConf will use the first <emphasis>writeable</emphasis> source.
          System administrators can impose <emphasis>mandatory</emphasis> settings on their
          users by placing a read-only source at the front of the path (note that "mandatory" 
          only means that existing programs won't let them change the value, users could
          hack their own copy of GConf that ignored system settings). Administrators can provide
          <emphasis>default</emphasis> values by placing a systemwide source at the end of the
          configuration source path.
        </para>
        
        <para>
          The source configuration file can contain "include" statements; once variables like 
          HOME are working, this feature can be used to include a .gconf.path file in the 
          user's home directory.  
        </para>

        <para>
          So once everything is working a <filename>/etc/gconf/path</filename> file might look 
          like this:
          <programlisting>
            # GConf configuration path file with an include statement
            xml:/etc/gconf.xml.mandatory
            include "HOME/.gconf.path"
            xml:/etc/gconf.xml.defaults
          </programlisting>
        </para>

        <warning>
          <title>GConf TODO Items: GUI feedback for mandatory settings, and variables in the path config file</title>
          <para>
            GConf is missing two important features:
            <itemizedlist>
              <listitem>
                <para>
                  When apps query a value, if GConf takes it from a read-only source it 
                  needs to tell the app that the value is not modifiable, so they 
                  can set the GUI element configuring that value insensitive and 
                  refuse to change the value. Otherwise very confusing behavior results.
                  This requires an API change to the client library. 
                </para>
              </listitem>
              <listitem>
                <para>
                  The config file should accept some special variables, such as 
                  HOME, expanding to the user's home directory. This allows admins 
                  to set up sources that depend on the current user.
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </warning>
      </sect3>

    </sect2>

  </sect1>

  <!-- Client Library -->
  <sect1>
    <title>C Language Client Library</title>
    
    <para>
      The GConf client library is used by applications
      to store or retrieve configuration data. This library presents 
      the lowest-level (but still fairly convenient) mode of access
      to the GConf database; the GConf database does not speak a
      public protocol and can not be accessed directly. 
    </para>

    <para>
      Convenience wrappers for the GConf client library may eventually 
      be written. A wrapper which performed client-side caching
      could also be useful; time will tell.      
    </para>

    <!-- Error Handling -->
    <sect2>
      <title>Error Handling</title>
      
      <para>
        Error handling isn't exciting but it's unfortunately
        necessary. Because even the initialization of the GConf
        library can fail, we have to cover error handling first.
      </para>

      <para>
        Errors are returned in two forms. The first is an
        <symbol>errno</symbol>-style enumerated value with type
        <symbol>GConfErrNo</symbol>, useful for switching on an error
        and taking different actions depending on the exact error that
        occurred. The second is human-readable text; human-readable
        errors automatically consist of both a
        <function>strerror()</function>-style string and a more
        detailed message. For any error, both of these forms will be
        available to you.
      </para>

      <para>
        The available values for <symbol>GConfErrNo</symbol> are:
        <variablelist>
          <varlistentry><term>G_CONF_SUCCESS</term>
            <listitem>
              <para>
                Indicates that there was no error.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_FAILED</term>
            <listitem>
              <para>
                Indicates that the operation fatally failed for 
                some fairly unpredictable and idiosyncratic reason
                not covered by the more specific error values.
                The error message will give details.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_NO_SERVER</term>
            <listitem>
              <para>
                The <command>gconfd</command> configuration server
                could not be contacted, and we couldn't or didn't
                respawn it for whatever reason. The error message 
                may give more details. This probably means either a
                bug in <command>gconfd</command> or a hosed local
                configuration.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_NO_PERMISSION</term>
            <listitem>
              <para>
                User was denied permission to access some resource
                at some point; perhaps a file in a file-based
                configuration backend, perhaps some authentication 
                tokens are wrong. The error message will give more details.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_BAD_ADDRESS</term>
            <listitem>
              <para>
                A configuration source address was invalid.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_BAD_KEY</term>
            <listitem>
              <para>
                A configuration key was invalid.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_PARSE_ERROR</term>
            <listitem>
              <para>
                Something had to be parsed, and it couldn't
                be. Typically, a string representation of a config 
                value found in a config file or obtained from the 
                user. Error message will often have more details.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_CORRUPT</term>
            <listitem>
              <para>
                Typically means that the text files or binary database
                used by some backend have gotten hosed. Most backends
                will try to self-repair, within reason. If they can't
                they will bail with this error.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_TYPE_MISMATCH</term>
            <listitem>
              <para>
                Some routines in the GConf libraries impose type
                constraints; if these are violated you get this error.
                For example, <function>g_conf_get_int()</function>
                returns this error if the value found is actually a 
                string.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_IS_DIR</term>
            <listitem>
              <para>
                This error is returned if you try to perform a key 
                operation on a name that turns out to be a directory.
                Some backends don't check for this error, they just 
                report that the key isn't set...
              </para>
            </listitem>
          </varlistentry>
          <varlistentry><term>G_CONF_IS_KEY</term>
            <listitem>
              <para>
                This error is returned if you try to perform a
                directory operation on a name that turns out to be 
                a key. Some backends don't check for this error...
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>

      <para>
        To obtain the current <symbol>GConfErrNo</symbol>, call the 
        <function>g_conf_errno()</function> function.
        <funcsynopsis>
          <funcsynopsisinfo>#include &lt;gconf/gconf.h&gt;</funcsynopsisinfo>
          <funcdef>GConfErrNo
            <function>g_conf_errno</function>
          </funcdef>
          <void>
        </funcsynopsis>
      </para>

      <para>
        To clear the current <symbol>GConfErrNo</symbol> (setting it
        to <symbol>G_CONF_SUCCESS</symbol>, call
        <function>g_conf_clear_error()</function> which is equivalent
        to setting the UNIX <symbol>errno</symbol> to 0:

        <funcsynopsis>
          <funcsynopsisinfo>#include &lt;gconf/gconf.h&gt;</funcsynopsisinfo>
          <funcdef>void
            <function>g_conf_clear_error</function>
          </funcdef>
          <void>
        </funcsynopsis>
      </para>

      <para>
        To obtain the current error message, call
        <function>g_conf_error()</function>. This message will include
        the results of <function>g_conf_strerror()</function> plus
        possible additional details about the problem.        
        <funcsynopsis>
          <funcsynopsisinfo>#include &lt;gconf/gconf.h&gt;</funcsynopsisinfo>
          <funcdef>const gchar* 
            <function>g_conf_error</function>
          </funcdef>
          <void>
        </funcsynopsis>
      </para>

      <para>
        <function>g_conf_strerror()</function> is not that useful,
        because you should use <function>g_conf_error()</function>
        instead to get additional details. However it's exported 
        publically in case you think of a use for it.
        <funcsynopsis>
          <funcsynopsisinfo>#include &lt;gconf/gconf.h&gt;</funcsynopsisinfo>
          <funcdef>const gchar* 
            <function>g_conf_strerror</function>
          </funcdef>
          <void>
        </funcsynopsis>
      </para>

      <para>
        <function>g_conf_set_error()</function> is used inside the
        library and inside the library backends. It is typically not
        useful to clients. It simply sets the current error, from a
        <symbol>GConfErrNo</symbol> and a
        <function>printf()</function>-style format and variable
        argument list.
        <funcsynopsis>
          <funcsynopsisinfo>#include &lt;gconf/gconf.h&gt;</funcsynopsisinfo>
          <funcdef>void
            <function>g_conf_set_error</function>
          </funcdef>
          <paramdef>GConfErrNo <parameter>en</parameter></paramdef>
          <paramdef>const gchar*
          <parameter>format</parameter></paramdef>
          <paramdef><parameter>...</parameter></paramdef>
        </funcsynopsis>
      </para>

      <warning>
        <title>GConf FIXME: thread safety for error system</title>
        <para>
          Clearly this has the same thread-safety problems as <symbol>errno</symbol>,
          I'm not sure what a good API to fix it would be however. Suggestions 
          welcome.
        </para>
      </warning>

    </sect2>


    <!-- Initialization -->
    <sect2>
      <title>Initialization</title>
      
      <para>
        The GConf client library must be initialized before use. 
        Initialization establishes a connection to the ORB (because
        CORBA is currently used to implement GConf, though clients
        never have to see this) and sets up some global data
        structures. <function>g_conf_init()</function> has no 
        arguments. (Well, right now it does have one, the name of your
        app, but I'm removing it soon.)
      </para>

      <para>
        Before initializing GConf, you can specify the ORB object
        reference to use when connecting to the configuration
        database; call <function>g_conf_set_orb()</function>. You
        would normally use this if you are writing a GNOME
        application, and you want to use
        <function>gnome_CORBA_init()</function> to obtain your ORB
        reference.
      </para>

      <warning>
        <title>Using GConf with GNOME</title>
        <para>
          If you use <function>gnome_CORBA_init()</function> to get your
          ORB reference, CORBA connections to your application are
          authenticated via <filename>libgnorba</filename>. If you let
          GConf set up the ORB, connections are authenticated in a
          GConf-specific way. Your authentication mechanism must match
          the one used by the <command>gconfd</command> per-user
          configuration daemon, which is never the GNOME way for
          now. This will obviously change before GConf goes into
          production in a GNOME environment, but it works great 
          for non-GNOME apps right now. :-)
        </para>
      </warning>

      <para>
        You can check whether GConf is initialized with
        <function>g_conf_initialized()</function>.
      </para>

    </sect2>

    <!-- GConfValue -->
    <sect2>
      <title>The <structname>GConfValue</structname> Datatype</title>
      
      <para>
        The <structname>GConfValue</structname> struct represents 
        a value that can be obtained from or stored in the
        configuration database. It is simply a type marker 
        and a union of several value types, with constructor,
        destructor, "setter" and "getter" functions. When possible 
        the GConf library allows you to deal with simple C types
        instead of a <structname>GConfValue</structname>, but 
        sometimes there is simply no way to know the type of an 
        object in advance. The <filename>libgnome/gnome-config.h</filename>
        interface simply returns strings in this case, for the
        programmer to parse manually; this was phenomenally broken and
        GConf fixes it with <structname>GConfValue</structname>.        
      </para>

      

    </sect2>

    <!-- Reading configuration values -->
    <sect2>
      <title>Reading Configuration Values</title>

      <para>
        
      </para>

    </sect2>
  </sect1>

</article>
<!-- Keep this comment at the end of the file
Local variables:
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
sgml-auto-insert-required-elements:t
sgml-balanced-tag-edit:t
sgml-normalize-trims:t
sgml-set-face:t
sgml-parent-document:nil
End:
-->

