* Move to a cut-and-pasted version of GError from GLib unstable branch, 
  replacing GConfError.

* Berkeley DB backend (note: consider issues surrounding various incompatible 
  versions of DB and historical problems with the upgrade path, cf. 
  RPM and gnome-mime-db)

* Performance tuning

* Document locking issues for backends (backends should perform
  their own locking, etc.)

* Document which database GConf will write to given multiple 
  writeable databases

* Fix spelling of "writable" throughout, or at least
  in public API (s/writeable/writable/g)

* Implement a way for backends to notify gconfd of changes they detect

* Implement a "database map"; this would be a tree structure (similar
  in implementation to GConfListeners). Rather than storing listeners
  at the tree nodes, store a list of databases in order, and 
  readability/writability of each database. Create a config file
  (perhaps in the GMarkup XML subset from glib 2.0) for configuring
  the database map. Figure out whether this can entirely replace
  the readable/writable methods from the backend vtable.
  It likely replaces the gconf/path configuration file. (Essentially
  the idea is a database path per key/directory, instead of a 
  global database path, giving administrators more flexibility.)

  Details to be figured out.

* GUI admin tool, and GUI user tool (are these the same?)

* Thread support for scalability; may require ORBit thread safety?
  Or a protocol with oneway CORBA methods (client requests a value,
  gconfd calls back when it has the value)

* Robustness against gconfd exit or crash; probably by logging
  the current list of clients to a file

* Life cycle management for gconfd (exit if no clients are alive, 
  maybe ping clients periodically)

* Maintain documentation

* API so clients can find out if they can write to a given key
  (gconf_key_is_writable() or the like)

* Implement the default error handlers in GConfClient

* Fix non-default GConfEngines: this means propagating change
  notifications from them to other engines with the same 
  databases. Or maybe instead we should use the mechanism
  used when the same database is in two gconfds (backend 
  notifies us of changes). Also, GConfEngine client side
  needs to store the source list used to create the 
  context ID, so if gconfd forgets the context, it can 
  simply be recreated. This will allow gconfd to forget old
  contexts.

